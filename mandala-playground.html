---
layout: sonification
title: "Mandala Playground - Interactive Sonification"
description: "Full-featured mandala sonification playground with real mandala images and advanced audio synthesis capabilities"
---

<style>
/* Full-screen playground styles using official ideia.me colors */
.playground-container {
  display: block;
  position: relative;
  width: 100%;
  min-height: 100vh;
  background: #0c0c0c;
  font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Menlo, Consolas, monospace;
  color: #ffffff;
  margin: -2rem -15px 2rem -15px; /* Negative margins to break out of container */
  padding: 0;
  overflow-x: hidden;
  overflow-y: auto;
}

/* Animated background grid */
.playground-container::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(90deg, rgba(59, 130, 246, 0.05) 1px, transparent 1px),
    linear-gradient(rgba(59, 130, 246, 0.05) 1px, transparent 1px);
  background-size: 50px 50px;
  z-index: -2;
  opacity: 0.3;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

/* Slide-based layout */
.playground-slides {
  display: flex;
  flex-direction: column;
  width: 100%;
  min-height: 40vh;
}

.slide {
  width: 100%;
  min-height: 50vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1.5rem;
  position: relative;
  scroll-snap-align: start;
}

.slide:first-child {
  min-height: 40vh; /* Banner slide is shorter */
}

/* Mandala Banner Slide */
.banner-slide {
  background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
  border-bottom: 3px solid #3b82f6;
  min-height: 50vh;
  overflow-y: auto;
  position: relative;
  padding: 1rem;
  padding-bottom: 120px; /* Space for speed control at bottom */
}

.banner-content {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  position: relative;
}

.mandala-banner {
  position: relative;
  max-width: 900px;
  width: 100%;
  height: 500px;
  margin: 0 auto;
}

.banner-mandala {
  width: 130px;
  height: 130px;
  border-radius: 50%;
  border: 3px solid rgba(59, 130, 246, 0.3);
  cursor: pointer;
  transition: all 0.3s ease;
  position: absolute;
  overflow: hidden;
  object-fit: cover;
  z-index: 1;
}

.banner-mandala.offset {
  z-index: 2;
}

.banner-mandala:hover {
  transform: scale(1.1);
  border-color: rgba(59, 130, 246, 0.6);
}

.banner-mandala.selected {
  transform: scale(1.15);
  border-color: #ffffff;
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

@keyframes rotate-mandala {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes rotate-mandala-reverse {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-360deg); }
}

/* Accelerator Slide */
.accelerator-slide {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  border-bottom: 3px solid #1abc9c;
}

.accelerator-content {
  text-align: center;
  max-width: 800px;
}

.accelerator-title {
  font-size: 2.5rem;
  color: #1abc9c;
  margin-bottom: 1rem;
  font-weight: bold;
}

.accelerator-subtitle {
  font-size: 1.2rem;
  color: #ecf0f1;
  margin-bottom: 3rem;
  opacity: 0.8;
}

.speed-control {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  text-align: center;
}

.speed-slider {
  width: 100%;
  height: 15px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(90deg, #e74c3c 0%, #f39c12 25%, #f1c40f 50%, #2ecc71 75%, #3498db 100%);
  border-radius: 10px;
  outline: none;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.speed-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 30px;
  height: 30px;
  background: #ecf0f1;
  border: 3px solid #1abc9c;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 15px rgba(26, 188, 156, 0.6);
  transition: all 0.2s ease;
}

.speed-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 25px rgba(26, 188, 156, 0.8);
}

.speed-display {
  margin-top: 2rem;
  font-size: 1.5rem;
  color: #1abc9c;
  font-weight: bold;
}

.selected-info {
  margin-top: 1rem;
  font-size: 1.2rem;
  color: #3b82f6;
  font-weight: bold;
}

/* Mandala Display Slide */
.mandala-display-slide {
  background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
  border-bottom: 3px solid #e74c3c;
}

.mandala-display-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3rem;
  max-width: 1000px;
  width: 100%;
}

.main-mandala-container {
  position: relative;
  width: 400px;
  height: 400px;
  border-radius: 50%;
  overflow: hidden;
  border: 4px solid #e74c3c;
  box-shadow: 0 0 50px rgba(231, 76, 60, 0.5);
  transition: all 0.3s ease;
  background: #1a1a1a;
}

.main-mandala-container:hover {
  transform: scale(1.1);
}

.main-mandala {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.3s ease;
  background: transparent;
}

.main-mandala.rotating {
  animation: rotate linear infinite;
}

.main-mandala.rotating-reverse {
  animation: rotate-reverse linear infinite;
}

@keyframes rotate-reverse {
  from { transform: rotate(0deg); }
  to { transform: rotate(-360deg); }
}

/* Color Palette Styles */
.color-palette-container {
  width: 100%;
  max-width: 800px;
  text-align: center;
}

.palette-title {
  font-size: 1.8rem;
  color: #e74c3c;
  margin-bottom: 2rem;
  font-weight: bold;
}

.color-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
  gap: 20px;
  max-width: 720px;
  margin: 0 auto;
}

.color-note {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  cursor: pointer;
  border: 4px solid rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
  position: relative;
  overflow: hidden;
  /* Remove any default background that might interfere */
  background-color: transparent;
}

.color-note:hover {
  transform: scale(1.3);
  z-index: 10;
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
}

.color-note.playing {
  animation: note-pulse 0.6s ease-out;
  transform: scale(1.4);
  z-index: 15;
}

@keyframes note-pulse {
  0% { transform: scale(1); box-shadow: 0 0 0 rgba(255, 255, 255, 0); }
  50% { transform: scale(1.6); box-shadow: 0 0 30px rgba(255, 255, 255, 0.6); }
  100% { transform: scale(1.4); box-shadow: 0 0 20px rgba(255, 255, 255, 0.4); }
}

/* Aspiral Reconstruction Slide */
.aspiral-slide {
  background: linear-gradient(135deg, #2c1810 0%, #3d2817 100%);
  border-bottom: 3px solid #f39c12;
}

.aspiral-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
  max-width: 1000px;
  width: 100%;
}

.aspiral-title {
  font-size: 2.2rem;
  color: #f39c12;
  margin-bottom: 1rem;
  font-weight: bold;
  text-align: center;
}

.aspiral-container {
  display: flex;
  align-items: center;
  gap: 3rem;
  flex-wrap: wrap;
  justify-content: center;
}

.aspiral-canvas-container {
  position: relative;
}

.aspiral-canvas {
  border: 4px solid #f39c12;
  border-radius: 50%;
  background: #1a1a1a;
  transition: all 0.3s ease;
  cursor: crosshair;
}

.aspiral-canvas:hover {
  transform: scale(1.04);
}

.aspiral-controls {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  align-items: center;
}

.aspiral-button {
  background: linear-gradient(135deg, #f39c12, #e67e22);
  border: none;
  border-radius: 12px;
  color: white;
  padding: 15px 30px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 6px 20px rgba(243, 156, 18, 0.3);
  font-family: inherit;
}

.aspiral-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(243, 156, 18, 0.5);
}

.aspiral-button:active {
  transform: translateY(0);
}

.aspiral-button.playing {
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  animation: button-pulse 2s ease-in-out infinite;
}

@keyframes button-pulse {
  0%, 100% { box-shadow: 0 6px 20px rgba(231, 76, 60, 0.3); }
  50% { box-shadow: 0 6px 20px rgba(231, 76, 60, 0.8); }
}

.speed-control-aspiral {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  width: 250px;
}

.speed-control-aspiral label {
  color: #f39c12;
  font-weight: bold;
  font-size: 14px;
}

.speed-slider-aspiral {
  width: 100%;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
  border-radius: 5px;
  outline: none;
}

.speed-slider-aspiral::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #ecf0f1;
  border: 2px solid #f39c12;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
}

.speed-slider-aspiral::-webkit-slider-thumb:hover {
  transform: scale(1.3);
  box-shadow: 0 0 15px rgba(243, 156, 18, 0.8);
}

.aspiral-dot {
  cursor: pointer;
  transition: all 0.1s ease;
}

.aspiral-dot:hover {
  transform: scale(2);
  z-index: 1000;
  filter: brightness(1.5);
}

.aspiral-dot.highlighted {
  animation: dot-highlight 0.5s ease-out;
}

@keyframes dot-highlight {
  0% { transform: scale(1); filter: brightness(1); }
  50% { transform: scale(3); filter: brightness(2); }
  100% { transform: scale(1); filter: brightness(1); }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .slide {
    padding: 0.5rem;
    min-height: 20vh;
  }
  
  .accelerator-title {
    font-size: 2rem;
  }
  
  .accelerator-subtitle {
    font-size: 1rem;
  }
  
  .main-mandala-container {
    width: 300px;
    height: 300px;
  }
  
  .color-note {
    width: 60px;
    height: 60px;
    font-size: 12px;
  }
  
  .color-grid {
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 15px;
  }
  
  .aspiral-container {
    flex-direction: column;
    gap: 2rem;
  }
  
  .aspiral-title {
    font-size: 1.8rem;
  }
  
  .banner-mandala {
    width: 100px;
    height: 100px;
  }
  
  .mandala-banner {
    max-width: 600px;
    height: 400px;
  }
}

@media (max-width: 480px) {
  .accelerator-title {
    font-size: 1.5rem;
  }
  
  .main-mandala-container {
    width: 250px;
    height: 250px;
  }
  
  .color-note {
    width: 50px;
    height: 50px;
    font-size: 10px;
  }
  
  .aspiral-canvas {
    width: 350px;
    height: 350px;
  }
  
  .banner-mandala {
    width: 80px;
    height: 80px;
  }
  
  .mandala-banner {
    max-width: 400px;
    height: 300px;
  }
  
  .banner-slide {
    padding-bottom: 140px; /* More space on small screens */
  }
  
  .speed-control {
    bottom: 15px;
    max-width: 350px;
    padding: 0 15px;
  }
}

.knob-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.knob {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: linear-gradient(135deg, #1e293b, #334155);
  border: 3px solid #3b82f6;
  position: relative;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), inset 0 2px 4px rgba(59, 130, 246, 0.2);
  transition: all 0.2s ease;
}

.knob:hover {
  border-color: #60a5fa;
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3), inset 0 2px 4px rgba(59, 130, 246, 0.3);
}

.knob::after {
  content: '';
  position: absolute;
  width: 4px;
  height: 20px;
  background: #ffffff;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  border-radius: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
}

.knob-label {
  color: #ffffff;
  font-size: 11px;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.knob-value {
  color: #7dd3fc;
  font-size: 10px;
  font-weight: bold;
}


/* Left Instrument Panel */
.instrument-panel {
  background: #111111;
  border-right: 3px solid #3b82f6;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 0;
  gap: 15px;
}

.instrument-emoji {
  width: 50px;
  height: 50px;
  border-radius: 10px;
  background: rgba(17, 17, 17, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  cursor: pointer;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.instrument-emoji:hover {
  background: rgba(59, 130, 246, 0.2);
  border-color: #3b82f6;
  transform: scale(1.1);
}

.instrument-emoji.active {
  background: linear-gradient(135deg, #3b82f6, #8b5cf6);
  border-color: #ffffff;
  box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
}

/* Main Area */
.main-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.5);
  padding: 20px;
  position: relative;
}

.mandala-container {
  position: relative;
  width: 600px;
  height: 600px;
  border-radius: 50%;
  overflow: hidden;
  margin-bottom: 20px;
}

.mandala-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.1s ease;
  cursor: pointer;
  user-select: none;
}

.mandala-image:hover {
  filter: brightness(1.1);
}

.mandala-image.rotating {
  animation: rotate linear infinite;
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Magnifier and effects */
.magnifier {
  position: absolute;
  width: 120px;
  height: 120px;
  border: 4px solid #3b82f6;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(2px);
  display: none;
  pointer-events: auto;
  z-index: 15;
  cursor: grab;
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.6);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: box-shadow 0.2s ease;
}

.magnifier:active {
  cursor: grabbing;
  box-shadow: 0 0 40px rgba(59, 130, 246, 0.9);
}

.magnifier-content {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 80px;
  height: 80px;
  transform: translate(-50%, -50%);
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid rgba(255, 255, 255, 0.8);
}

.navigation {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.navigation button {
  flex: 1;
  padding: 12px;
  border: none;
  border-radius: 8px;
  background: rgba(59, 130, 246, 0.8);
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
  font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Menlo, Consolas, monospace;
}

.navigation button:hover {
  background: rgba(59, 130, 246, 1);
}


/* Piano Keyboard */
.piano-keyboard {
  grid-column: 1 / -1;
  background: #111111;
  border-top: 3px solid #3b82f6;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.5);
}

.keyboard {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  background: #1a1a1a;
  padding: 15px;
  border-radius: 10px;
  box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.5);
  justify-content: center;
  flex-wrap: wrap;
}

.key {
  position: relative;
  cursor: pointer;
  user-select: none;
  transition: all 0.1s ease;
}

.white-key {
  width: 40px;
  height: 120px;
  background: linear-gradient(145deg, #e2e8f0, #cbd5e0);
  border: 2px solid #718096;
  border-radius: 0 0 5px 5px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding: 10px 5px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.white-key:hover {
  background: linear-gradient(145deg, #cbd5e0, #a0a0a0);
  transform: translateY(2px);
}

.white-key.active {
  background: linear-gradient(135deg, #3b82f6, #8b5cf6) !important;
  color: white;
  transform: translateY(4px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.black-key {
  width: 25px;
  height: 80px;
  background: linear-gradient(145deg, #1a1a1a, #000000);
  border: 2px solid #333333;
  border-radius: 0 0 3px 3px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding: 10px 5px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
  margin: 0 -12px;
  z-index: 2;
  position: relative;
}

.black-key:hover {
  background: linear-gradient(145deg, #333333, #1a1a1a);
  transform: translateY(2px);
}

.black-key.active {
  background: linear-gradient(135deg, #3b82f6, #8b5cf6) !important;
  color: white;
  transform: translateY(4px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Color-based keyboard keys */
.color-key {
  width: 60px;
  height: 100px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding: 10px 5px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.1s ease;
  cursor: pointer;
  user-select: none;
  border: 2px solid rgba(255, 255, 255, 0.2);
  position: relative;
  overflow: hidden;
}

.color-key:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
  border-color: rgba(255, 255, 255, 0.5);
}

.color-key.active {
  transform: translateY(2px) scale(0.95);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
  filter: brightness(1.3);
}

.color-key::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  z-index: 1;
  pointer-events: none;
}

.note-label {
  font-size: 11px;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
  z-index: 2;
  position: relative;
  padding: 2px 6px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(2px);
  margin-top: auto;
}

/* Touch-friendly styling */
@media (hover: none) and (pointer: coarse) {
  .color-key {
    width: 70px;
    height: 110px;
  }
  
  .color-key:active {
    transform: scale(0.9);
    transition: transform 0.1s ease;
  }
}

/* Close button removed - playground is always active */

/* Responsive */
@media (max-width: 768px) {
  .playground-container {
    margin: -1rem -15px 1rem -15px;
    padding: 1rem 0;
  }
  
  .playground-grid {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr auto;
  }
  
  .mandala-container {
    width: 350px;
    height: 350px;
  }
}
</style>

<div id="playground-container" class="playground-container">
  
  <div class="playground-slides">
    <div class="slide banner-slide">
      <div class="banner-content">
        <div class="mandala-banner" id="mandala-banner">
        </div>
      </div>
      <div class="speed-control">
        <input type="range" id="banner-speed" class="speed-slider" min="-300" max="300" value="1" step="1">
        <div class="speed-display" id="speed-display">Speed: 1.0x</div>
        <div class="selected-info" id="selected-info">
          Selected: Mandala #<span id="selected-number">1</span>
        </div>
      </div>
    </div>
    <div class="slide mandala-display-slide">
      <div class="mandala-display-content">
        <div class="main-mandala-container">
          <img class="main-mandala" id="selected-mandala" alt="Selected Mandala" crossorigin="anonymous">
        </div>
        <div class="color-palette-container">
          <h2 class="palette-title">ðŸŽ¨ Color Palette - Play the Notes</h2>
          <div class="color-grid" id="color-grid">
          </div>
        </div>
      </div>
    </div>

    <div class="slide aspiral-slide">
      <div class="aspiral-content">
        <div class="aspiral-container">
          <div class="aspiral-canvas-container">
            <canvas id="aspiral-canvas" class="aspiral-canvas" width="500" height="500"></canvas>
          </div>
          
          <div class="aspiral-controls">
            <button id="aspiral-play-btn" class="aspiral-button">ðŸŽµ Play Aspiral</button>
            
            <div class="speed-control-aspiral">
              <label for="aspiral-speed">Speed (0.005 - 5)</label>
              <input type="range" id="aspiral-speed" class="speed-slider-aspiral" min="0.005" max="5" value="2" step="0.05">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Playground is now always active -->

<!-- Required JavaScript libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>

<script>
let playgroundApp = null;

// Auto-initialize playground when page loads
document.addEventListener('DOMContentLoaded', function() {
  if (!playgroundApp) {
    playgroundApp = new MandalaPlayground();
  }
});

class MandalaPlayground {
  constructor() {
    this.mandalaIndex = 0;
    this.mandalas = this.generateMandalaList();
    this.colorThief = new ColorThief();
    this.currentPalette = [];
    this.extractedColors = [];
    this.selectedMandalaIndex = 0;
    this.bannerSpeed = 1;
    this.isAspiralPlaying = false;
    this.aspiralDots = [];
    this.aspiralPlayIndex = 0;
    this.aspiralAnimationSpeed = 2;
    this.sourceImageData = null;
    this.audioEnabled = false;
    this.synth = null;
    this.currentPlayingColorIndex = -1;
    
    this.setupAudio();
    this.initializeElements();
    this.bindEvents();
    this.createMandalaCarousel();
    this.addAudioNotice();
    this.setupResizeListener();
    
    // Initialize speed display and selected mandala number
    this.updateSpeedDisplay();
    this.updateSelectedMandalaNumber();
    
    // Load the initial mandala (this will trigger color extraction and aspiral)
    this.loadSelectedMandala();
  }

  generateMandalaList() {
    const mandalas = [];
    // Generate list of actually available mandala files
    const mandalaFiles = [
      '01b.png', '02b.png', '03b.png', '04b.png', '05b.png', '06b.png', '07b.png', '08b.png', '09b.png',
      '010b.png', '011b.png', '012b.png', '013b.png', '014b.png', '015b.png', '016b.png', '017b.png',
      '018b.png', '019b.png', '020b.png', '021b.png', '022b.png', '023b.png', '024b.png', '025b.png', '026b.png'
    ];
    
    mandalaFiles.forEach((filename, index) => {
      mandalas.push({
        number: index + 1,
        filename: filename,
        path: `/images/mandalas/${filename}`
      });
    });
    
    return mandalas;
  }

  async setupAudio() {
    try {
      // Wait for user interaction before setting up audio
      this.audioEnabled = false;
      this.synth = null;
      
      // Initialize audio context properly
      await this.initializeAudioContext();
    } catch (error) {
      console.error('Failed to setup audio:', error);
    }
  }

  async initializeAudioContext() {
    try {
      if (window.Tone && Tone.context.state !== 'running') {
        await Tone.start();
        console.log('Audio context started');
      }
      
      // Create synth after audio context is running
      this.synth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.8 }
      }).toDestination();
      
      this.audioEnabled = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize audio context:', error);
      return false;
    }
  }

  initializeElements() {
    this.elements = {
      mandalaCarousel: document.getElementById('mandala-banner'),
      selectedMandala: document.getElementById('selected-mandala'),
      colorGrid: document.getElementById('color-grid'),
      aspiralCanvas: document.getElementById('aspiral-canvas'),
      bannerSpeedSlider: document.getElementById('banner-speed'),
      speedDisplay: document.getElementById('speed-display'),
      selectedNumber: document.getElementById('selected-number'),
      aspiralPlayBtn: document.getElementById('aspiral-play-btn'),
      aspiralSpeedSlider: document.getElementById('aspiral-speed'),
      aspiralSpeedLabel: document.querySelector('label[for="aspiral-speed"]')
    };
  }

  // Setup window resize listener for responsive layout
  setupResizeListener() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        this.createMandalaCarousel();
        this.updateMandalaRotations();
      }, 250);
    });
  }

  // Add audio notice for user interaction
  addAudioNotice() {
    const container = document.getElementById('playground-container');
    if (!container) return;
    
    const notice = document.createElement('div');
    notice.className = 'audio-notice';
    notice.innerHTML = 'ðŸ”Š Click anywhere to enable audio for the mandala sonification';
    notice.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(26, 188, 156, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    `;
    
    notice.addEventListener('click', async () => {
      const success = await this.initializeAudioContext();
      if (success) {
        notice.style.opacity = '0';
        setTimeout(() => notice.remove(), 300);
      }
    });
    
    document.body.appendChild(notice);
  }

  // Create overlapping mandala grid panel for the banner
  createMandalaCarousel() {
    const panel = this.elements.mandalaCarousel;
    panel.innerHTML = '';
    
    // Calculate positions for overlapping grid
    const positions = this.calculateOverlappingPositions();
    
    // Create grid of all mandalas with calculated positions
    this.mandalas.forEach((mandala, index) => {
      const mandalaElement = document.createElement('img');
      mandalaElement.className = 'banner-mandala';
      mandalaElement.crossOrigin = 'anonymous';
      mandalaElement.src = mandala.path;
      mandalaElement.alt = `Mandala ${mandala.number}`;
      
      // Position the mandala
      if (positions[index]) {
        mandalaElement.style.left = positions[index].x + 'px';
        mandalaElement.style.top = positions[index].y + 'px';
        
        // Add offset class for overlapping mandalas
        if (positions[index].offset) {
          mandalaElement.classList.add('offset');
        }
      }
      
      if (index === this.selectedMandalaIndex) {
        mandalaElement.classList.add('selected');
      }
      
      mandalaElement.addEventListener('click', () => {
        this.selectMandala(index);
      });
      
      mandalaElement.addEventListener('error', (error) => {
        console.error('Failed to load banner mandala:', mandala.path);
      });
      
      panel.appendChild(mandalaElement);
    });
  }
  
  // Calculate positions for overlapping grid layout
  calculateOverlappingPositions() {
    const positions = [];
    
    // Responsive sizing based on screen width
    const screenWidth = window.innerWidth;
    let containerWidth, containerHeight, mandalaSize, spacing;
    
    if (screenWidth <= 480) {
      containerWidth = 400;
      containerHeight = 300;
      mandalaSize = 80;
      spacing = 70;
    } else if (screenWidth <= 768) {
      containerWidth = 600;
      containerHeight = 400;
      mandalaSize = 100;
      spacing = 85;
    } else {
      containerWidth = 900;
      containerHeight = 500;
      mandalaSize = 130;
      spacing = 110;
    }
    
    // Calculate how many mandalas fit per row
    const mandalsPerRow = Math.floor((containerWidth - mandalaSize) / spacing) + 1;
    const rows = Math.ceil(this.mandalas.length / mandalsPerRow);
    
    let mandalaIndex = 0;
    
    for (let row = 0; row < rows && mandalaIndex < this.mandalas.length; row++) {
      const isOffsetRow = row % 2 === 1;
      const rowY = row * (spacing * 0.7); // Vertical overlap
      
      // Calculate starting X position for centering
      const mandalsInThisRow = Math.min(mandalsPerRow, this.mandalas.length - mandalaIndex);
      const totalRowWidth = (mandalsInThisRow - 1) * spacing + mandalaSize;
      const startX = (containerWidth - totalRowWidth) / 2;
      
      for (let col = 0; col < mandalsPerRow && mandalaIndex < this.mandalas.length; col++) {
        let x = startX + col * spacing;
        let y = rowY;
        
        // Offset every other row horizontally for honeycomb effect
        if (isOffsetRow) {
          x += spacing / 2;
        }
        
        // Ensure mandalas stay within bounds
        if (x + mandalaSize > containerWidth) break;
        if (y + mandalaSize > containerHeight) break;
        
        positions[mandalaIndex] = {
          x: Math.max(0, x),
          y: Math.max(0, y),
          offset: isOffsetRow
        };
        
        mandalaIndex++;
      }
    }
    
    return positions;
  }
  
  // Select a mandala and update all reactive components
  selectMandala(index) {
    this.selectedMandalaIndex = index;
    this.updateMandalaSelection();
    this.updateSelectedMandalaNumber();
    this.loadSelectedMandala();
    // Aspiral reconstruction will be called after color extraction in createColorPalette
  }
  
  // Update the selected mandala number display
  updateSelectedMandalaNumber() {
    if (this.elements.selectedNumber) {
      this.elements.selectedNumber.textContent = this.selectedMandalaIndex + 1;
    }
  }

  // Update speed display with RPM calculation
  updateSpeedDisplay() {
    const direction = this.bannerSpeed >= 0 ? 'â†’' : 'â†';
    const absSpeed = Math.abs(this.bannerSpeed);
    
    // Calculate RPM (assuming base rotation is 1 rotation per 10 seconds)
    const baseRPM = 6; // 60 seconds / 10 seconds per rotation
    const currentRPM = baseRPM * absSpeed;
    
    this.elements.speedDisplay.textContent = `Speed: ${direction} ${absSpeed.toFixed(1)}x (${currentRPM.toFixed(1)} RPM)`;
    
    // Update selected mandala rotation
    this.updateSelectedMandalaRotation();
  }

  // Update selected mandala rotation
  updateSelectedMandalaRotation() {
    const selectedMandala = this.elements.selectedMandala;
    if (!selectedMandala) return;

    if (Math.abs(this.bannerSpeed) > 0) {
      const rotationSpeed = this.bannerSpeed;
      const duration = Math.abs(10 / rotationSpeed);
      
      // Remove existing animation classes
      selectedMandala.classList.remove('rotating', 'rotating-reverse');
      
      // Add appropriate animation class
      if (rotationSpeed >= 0) {
        selectedMandala.classList.add('rotating');
      } else {
        selectedMandala.classList.add('rotating-reverse');
      }
      
      // Set animation duration
      selectedMandala.style.animationDuration = `${duration}s`;
    } else {
      selectedMandala.classList.remove('rotating', 'rotating-reverse');
      selectedMandala.style.animation = 'none';
    }
  }
  
  // Update visual selection across all components
  updateMandalaSelection() {
    // Update banner selection
    const bannerMandalas = this.elements.mandalaCarousel.querySelectorAll('.banner-mandala');
    bannerMandalas.forEach((mandala, index) => {
      mandala.classList.toggle('selected', index === this.selectedMandalaIndex);
    });
  }
  
  // Load and display selected mandala with color extraction
  loadSelectedMandala() {
    const selectedMandala = this.mandalas[this.selectedMandalaIndex];
    const mandalaImg = this.elements.selectedMandala;
    
    console.log('Loading mandala:', selectedMandala.path);
    
    mandalaImg.onload = () => {
      console.log('Mandala loaded successfully');
      this.updateSelectedMandalaRotation(); // Apply rotation when mandala loads
      setTimeout(() => this.extractColors(), 50); // Small delay to ensure image is fully rendered
    };
    
    mandalaImg.onerror = (error) => {
      console.error('Failed to load mandala:', selectedMandala.path, error);
      // Use fallback colors if image fails to load
      this.extractColorsManually();
    };
    
    mandalaImg.crossOrigin = 'anonymous';
    mandalaImg.src = selectedMandala.path;
  }

  // Extract 12 dominant colors from selected mandala
  extractColors() {
    try {
      if (!this.elements.selectedMandala.complete || !this.elements.selectedMandala.naturalWidth) {
        console.log('Image not ready, retrying in 100ms...');
        setTimeout(() => this.extractColors(), 100);
        return;
      }

      console.log('Attempting to extract colors from:', this.elements.selectedMandala.src);
      
      // Use ColorThief to extract colors
      if (window.ColorThief && this.colorThief) {
        this.extractedColors = this.colorThief.getPalette(this.elements.selectedMandala, 12);
        console.log('ColorThief extracted colors:', this.extractedColors);
        
        if (this.extractedColors && this.extractedColors.length >= 6) {
          // Ensure we have 12 colors by duplicating if needed
          while (this.extractedColors.length < 12) {
            this.extractedColors.push(this.extractedColors[this.extractedColors.length % 6]);
          }
          this.extractedColors = this.extractedColors.slice(0, 12);
          this.createColorPalette();
          return;
        }
      }
      
      // Fallback to manual extraction if ColorThief fails
      console.log('ColorThief failed, using manual extraction...');
      this.extractColorsManually();
      
    } catch (error) {
      console.error('Error extracting colors:', error);
      this.extractColorsManually();
    }
  }
  
  // Manual color extraction fallback
  extractColorsManually() {
    try {
      console.log('Starting manual color extraction...');
      
      // Create canvas to sample colors
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = this.elements.selectedMandala;
      
      if (!img || !img.complete || !img.naturalWidth) {
        console.log('Image not ready for manual extraction, using fallback colors');
        this.useFallbackColors();
        return;
      }
      
      canvas.width = 200;
      canvas.height = 200;
      ctx.drawImage(img, 0, 0, 200, 200);
      
      const imageData = ctx.getImageData(0, 0, 200, 200);
      const data = imageData.data;
      const colorCounts = {};
      
      // Sample every 8th pixel to get more diverse colors
      for (let i = 0; i < data.length; i += 32) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        
        if (a > 100 && (r + g + b) > 60) { // Skip transparent and very dark pixels
          // Less aggressive quantization for better color fidelity
          const key = `${Math.round(r/15)*15},${Math.round(g/15)*15},${Math.round(b/15)*15}`;
          colorCounts[key] = (colorCounts[key] || 0) + 1;
        }
      }
      
      // Get top 12 colors
      const sortedColors = Object.entries(colorCounts)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 12)
        .map(([color]) => color.split(',').map(Number));
      
      if (sortedColors.length > 0) {
        this.extractedColors = sortedColors;
        // Fill with generated colors if not enough
        while (this.extractedColors.length < 12) {
          const hue = (this.extractedColors.length * 30) % 360;
          const [r, g, b] = this.hslToRgb(hue, 70, 60);
          this.extractedColors.push([r, g, b]);
        }
        console.log('Manual extraction successful:', this.extractedColors);
      } else {
        console.log('No colors found, using fallback');
        this.useFallbackColors();
      }
      
      this.createColorPalette();
      
    } catch (error) {
      console.error('Manual extraction failed:', error);
      this.useFallbackColors();
    }
  }
  
  // Use fallback colors
  useFallbackColors() {
    this.extractedColors = [
      [255, 107, 107], [78, 205, 196], [69, 183, 209], [150, 206, 180],
      [254, 202, 87], [255, 159, 243], [84, 160, 255], [95, 39, 205],
      [0, 210, 211], [255, 159, 67], [16, 172, 132], [238, 90, 36]
    ];
    console.log('Using fallback colors:', this.extractedColors);
    this.createColorPalette();
  }
  
  // HSL to RGB helper
  hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    const a = s * Math.min(l, 1 - l);
    const f = n => {
      const k = (n + h * 12) % 12;
      return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  }
  
  // Create interactive color palette
  createColorPalette() {
    const colorGrid = this.elements.colorGrid;
    colorGrid.innerHTML = '';
    
    console.log('Creating color palette with colors:', this.extractedColors);
    
    if (!this.extractedColors || this.extractedColors.length === 0) {
      console.error('No extracted colors available, using fallback');
      this.extractedColors = [
        [255, 107, 107], [78, 205, 196], [69, 183, 209], [150, 206, 180],
        [254, 202, 87], [255, 159, 243], [84, 160, 255], [95, 39, 205],
        [0, 210, 211], [255, 159, 67], [16, 172, 132], [238, 90, 36]
      ];
    }
    
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    this.extractedColors.forEach((color, index) => {
      const [r, g, b] = color;
      const noteName = noteNames[index];
      
      const colorNote = document.createElement('div');
      colorNote.className = 'color-note';
      
      // Force the background color with !important
      const colorStyle = `rgb(${r}, ${g}, ${b})`;
      colorNote.style.setProperty('background-color', colorStyle, 'important');
      colorNote.style.color = this.getContrastColor(r, g, b);
      colorNote.textContent = noteName;
      colorNote.title = `${noteName} - rgb(${r}, ${g}, ${b})`;
      
      console.log(`Color note ${index}: ${noteName} = rgb(${r}, ${g}, ${b}) -> ${colorStyle}`);
      
      colorNote.addEventListener('click', async () => {
        await this.playColorNote(index);
      });
      
      colorGrid.appendChild(colorNote);
    });
    
    console.log(`Color palette created with ${this.extractedColors.length} colors`);
    
    // Update banner mandala rotation with colors
    this.updateMandalaRotations();
    
    // Now that we have colors, generate aspiral reconstruction
    this.generateAspiralReconstruction();
  }
  
  // Generate aspiral reconstruction from selected mandala
  generateAspiralReconstruction() {
    const canvas = this.elements.aspiralCanvas;
    const ctx = canvas.getContext('2d');
    
    console.log('Starting aspiral reconstruction...');
    
    // Clear previous reconstruction
    ctx.clearRect(0, 0, 350, 350);
    this.aspiralDots = [];
    
    // Ensure we have extracted colors first
    if (!this.extractedColors || this.extractedColors.length === 0) {
      console.log('No extracted colors, waiting for color extraction...');
      setTimeout(() => this.generateAspiralReconstruction(), 500);
      return;
    }
    
    // Load mandala image data for aspiral algorithm
    this.loadMandalaImageData().then(() => {
      console.log('Mandala image data loaded, creating aspiral dots...');
      this.createAspiralDots();
    }).catch((error) => {
      console.error('Failed to load aspiral data:', error);
      // Create a simple fallback visualization
      this.createFallbackAspiral();
    });
  }
  
  // Load mandala image data for pixel sampling
  loadMandalaImageData() {
    return new Promise((resolve, reject) => {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 500;
      tempCanvas.height = 500;
      const tempCtx = tempCanvas.getContext('2d');
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      
      img.onload = () => {
        try {
          console.log('Aspiral mandala loaded:', img.src);
          // Scale and draw image
          const size = Math.min(img.width, img.height);
          const scale = 450 / size; // Leave some padding (50px total)
          const scaledWidth = img.width * scale;
          const scaledHeight = img.height * scale;
          const offsetX = (500 - scaledWidth) / 2;
          const offsetY = (500 - scaledHeight) / 2;
          
          tempCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
          this.sourceImageData = tempCtx.getImageData(0, 0, 500, 500);
          console.log('Aspiral image data ready');
          resolve();
        } catch (error) {
          console.error('Error processing aspiral image:', error);
          reject(error);
        }
      };
      
      img.onerror = (error) => {
        console.error('Failed to load aspiral mandala:', this.mandalas[this.selectedMandalaIndex].path, error);
        reject(error);
      };
      
      const mandalaPath = this.mandalas[this.selectedMandalaIndex].path;
      console.log('Loading aspiral mandala:', mandalaPath);
      img.src = mandalaPath;
    });
  }

  // Create fallback aspiral if image loading fails
  createFallbackAspiral() {
    const canvas = this.elements.aspiralCanvas;
    const ctx = canvas.getContext('2d');
    
    console.log('Creating fallback aspiral with extracted colors');
    
    const centerX = 250;
    const centerY = 250;
    const maxRadius = 225;
    const totalSteps = 1500;
    
    this.aspiralDots = [];
    
    for (let step = 0; step < totalSteps; step++) {
      const progress = step / totalSteps;
      const theta = progress * Math.PI * 20; // 10 rotations
      const radius = progress * maxRadius;
      
      const x = centerX + radius * Math.cos(theta);
      const y = centerY + radius * Math.sin(theta);
      
      // Use extracted colors in sequence
      const colorIndex = step % this.extractedColors.length;
      const [r, g, b] = this.extractedColors[colorIndex];
      
      // Draw dot
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2);
      ctx.fill();
      
      // Store dot info for interactive playback
      this.aspiralDots.push({
        x, y, r, g, b, step,
        colorIndex: colorIndex
      });
    }
    
    // Add hover listeners to canvas
    this.setupAspiralInteraction();
  }

  // Create aspiral dots from image data
  createAspiralDots() {
    const canvas = this.elements.aspiralCanvas;
    const ctx = canvas.getContext('2d');
    
    console.log('Creating aspiral dots from source image data');
    
    if (!this.sourceImageData) {
      console.error('No source image data available, using fallback');
      this.createFallbackAspiral();
      return;
    }
    
    const centerX = 250;
    const centerY = 250;
    const maxRadius = 225;
    const totalSteps = 5000;
    let validPixels = 0;
    
    for (let step = 0; step < totalSteps; step++) {
      const progress = step / totalSteps;
      const theta = progress * Math.PI * 60; // 30 rotations
      const radius = progress * maxRadius;
      
      const x = centerX + radius * Math.cos(theta);
      const y = centerY + radius * Math.sin(theta);
      
      // Sample pixel color
      const [r, g, b, a] = this.samplePixel(x, y);
      
      if (a > 50) {
        validPixels++;
        // Draw dot
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 1)`;
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Store dot info for interactive playback
        this.aspiralDots.push({
          x, y, r, g, b, step,
          colorIndex: this.findClosestColorIndex(r, g, b)
        });
      }
    }
    
    console.log(`Aspiral created: ${validPixels} valid pixels out of ${totalSteps} steps`);
    
    // If very few valid pixels, use fallback
    if (validPixels < 100) {
      console.log('Too few valid pixels, using fallback aspiral');
      ctx.clearRect(0, 0, 350, 350);
      this.createFallbackAspiral();
      return;
    }
    
    // Add hover listeners to canvas
    this.setupAspiralInteraction();
  }
  
  // Sample pixel from source image data
  samplePixel(x, y) {
    if (!this.sourceImageData || x < 0 || x >= 500 || y < 0 || y >= 500) {
      return [0, 0, 0, 0];
    }
    
    const index = (Math.floor(y) * 500 + Math.floor(x)) * 4;
    return [
      this.sourceImageData.data[index],
      this.sourceImageData.data[index + 1],
      this.sourceImageData.data[index + 2],
      this.sourceImageData.data[index + 3]
    ];
  }
  
  // Find closest color in extracted palette
  findClosestColorIndex(r, g, b) {
    let minDistance = Infinity;
    let closestIndex = 0;
    
    this.extractedColors.forEach((color, index) => {
      const [pr, pg, pb] = color;
      const distance = Math.sqrt((r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2);
      if (distance < minDistance) {
        minDistance = distance;
        closestIndex = index;
      }
    });
    
    return closestIndex;
  }
  
  // Setup mouse interaction for aspiral canvas
  setupAspiralInteraction() {
    const canvas = this.elements.aspiralCanvas;
    let lastHighlightedDot = null;
    let throttleTimeout = null;
    
    canvas.addEventListener('mousemove', (e) => {
      // Throttle mouse events for better performance
      if (throttleTimeout) return;
      
      throttleTimeout = setTimeout(() => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Find closest dot to mouse with smaller radius
        let closestDot = null;
        let minDistance = Infinity;
        
        this.aspiralDots.forEach(dot => {
          // Skip already highlighted dots
          if (dot.highlighted) return;
          
          const distance = Math.sqrt((mouseX - dot.x) ** 2 + (mouseY - dot.y) ** 2);
          if (distance < 5 && distance < minDistance) { // Reduced radius to 5px
            minDistance = distance;
            closestDot = dot;
          }
        });
        
        // Only interact with a new dot (prevent repeated interactions)
        if (closestDot && closestDot !== lastHighlightedDot) {
          this.playColorNote(closestDot.colorIndex);
          this.highlightDot(closestDot);
          lastHighlightedDot = closestDot;
        }
        
        throttleTimeout = null;
      }, 50); // 50ms throttle
    });
    
    // Reset last highlighted dot when mouse leaves canvas
    canvas.addEventListener('mouseleave', () => {
      lastHighlightedDot = null;
      if (throttleTimeout) {
        clearTimeout(throttleTimeout);
        throttleTimeout = null;
      }
    });
  }
  
  // Highlight a dot visually with scaling based on animation speed
  highlightDot(dot) {
    // Mark dot as highlighted
    dot.highlighted = true;
    dot.highlightTime = Date.now();
    
    // Calculate timing based on animation speed
    const baseDelay = 1000 / (this.aspiralAnimationSpeed * 20);
    const scaleDuration = Math.max(150, Math.min(600, baseDelay * 0.8)); // 80% of note duration
    const holdDuration = Math.max(50, Math.min(300, baseDelay * 0.3));   // 30% of note duration
    
    // Create a temporary visual element for scaling effect
    const canvas = this.elements.aspiralCanvas;
    const scaleDot = document.createElement('div');
    scaleDot.style.cssText = `
      position: absolute;
      left: ${dot.x - 3}px;
      top: ${dot.y - 3}px;
      width: 6px;
      height: 6px;
      background: rgb(${dot.r}, ${dot.g}, ${dot.b});
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
      transition: all ${scaleDuration}ms ease;
      transform: scale(3);
      box-shadow: 0 0 15px rgba(${dot.r}, ${dot.g}, ${dot.b}, 0.8);
      filter: brightness(1.5);
    `;
    
    canvas.parentElement.appendChild(scaleDot);
    
    // Remove the scaled dot after animation with timing based on speed
    setTimeout(() => {
      scaleDot.style.transform = 'scale(1)';
      scaleDot.style.filter = 'brightness(1)';
      scaleDot.style.boxShadow = 'none';
      setTimeout(() => {
        if (scaleDot.parentElement) {
          scaleDot.parentElement.removeChild(scaleDot);
        }
        if (dot.highlighted) {
          dot.highlighted = false;
        }
      }, scaleDuration);
    }, holdDuration);
  }
  
  
  // Play aspiral animation
  playAspiralAnimation() {
    if (this.isAspiralPlaying) {
      this.stopAspiralAnimation();
      return;
    }
    
    this.isAspiralPlaying = true;
    this.aspiralPlayIndex = 0;
    this.elements.aspiralPlayBtn.textContent = 'â¹ Stop';
    this.elements.aspiralPlayBtn.classList.add('playing');
    
    this.animateAspiralDots();
  }
  
  // Animate through aspiral dots with proper timing
  animateAspiralDots() {
    if (!this.isAspiralPlaying || this.aspiralPlayIndex >= this.aspiralDots.length) {
      this.stopAspiralAnimation();
      return;
    }
    
    const dot = this.aspiralDots[this.aspiralPlayIndex];
    
    // Play note and highlight
    this.playColorNote(dot.colorIndex);
    this.highlightDot(dot);
    
    // Highlight corresponding color in palette with timing based on animation speed
    const colorNotes = this.elements.colorGrid.querySelectorAll('.color-note');
    if (colorNotes[dot.colorIndex]) {
      colorNotes[dot.colorIndex].classList.add('playing');
      
      // Calculate timeout based on animation speed - reduced duration for subtlety
      const notePlayDuration = Math.max(200, 600 / (this.aspiralAnimationSpeed * 2));
      setTimeout(() => {
        colorNotes[dot.colorIndex].classList.remove('playing');
      }, notePlayDuration);
    }
    
    this.aspiralPlayIndex++;
    
    // Continue animation with speed control using requestAnimationFrame for smoother performance
    const delay = Math.max(50, 1000 / (this.aspiralAnimationSpeed * 20)); // Reduced frequency to prevent timing conflicts
    this.aspiralAnimationTimeout = setTimeout(() => {
      if (this.isAspiralPlaying) {
        requestAnimationFrame(() => this.animateAspiralDots());
      }
    }, delay);
  }
  
  // Stop aspiral animation
  stopAspiralAnimation() {
    this.isAspiralPlaying = false;
    if (this.aspiralAnimationTimeout) {
      clearTimeout(this.aspiralAnimationTimeout);
      this.aspiralAnimationTimeout = null;
    }
    this.elements.aspiralPlayBtn.textContent = 'ðŸŽµ Play Aspiral';
    this.elements.aspiralPlayBtn.classList.remove('playing');
  }
  
  // Play color note with proper audio context handling
  async playColorNote(colorIndex) {
    try {
      // Ensure audio context is running
      if (!this.audioEnabled || !this.synth) {
        await this.initializeAudioContext();
      }
      
      if (!this.synth) {
        console.warn('Audio synth not available');
        return;
      }
      
      // Update current playing color for button styling
      this.currentPlayingColorIndex = colorIndex;
      this.updateAspiralButtonColor();
      
      const pentatonic = [0, 2, 4, 7, 9]; // C, D, E, G, A
      const baseFreq = 261.63; // C4
      const noteIndex = colorIndex % pentatonic.length;
      const semitones = pentatonic[noteIndex];
      const frequency = baseFreq * Math.pow(2, semitones / 12);
      
      // Use Tone.now() to schedule notes properly and avoid timing conflicts
      const now = Tone.now();
      this.synth.triggerAttackRelease(frequency, "8n", now);
      
      // Visual feedback on color palette with moderate duration for manual clicks
      const colorNotes = this.elements.colorGrid.querySelectorAll('.color-note');
      if (colorNotes[colorIndex]) {
        colorNotes[colorIndex].classList.add('playing');
        setTimeout(() => {
          colorNotes[colorIndex].classList.remove('playing');
        }, 400); // Moderate duration for manual clicks
      }
    } catch (error) {
      console.error('Error playing color note:', error);
    }
  }

  // Update aspiral button color based on currently playing note
  updateAspiralButtonColor() {
    const button = this.elements.aspiralPlayBtn;
    if (this.currentPlayingColorIndex >= 0 && this.extractedColors && this.extractedColors[this.currentPlayingColorIndex]) {
      const [r, g, b] = this.extractedColors[this.currentPlayingColorIndex];
      button.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
      button.style.color = this.getContrastColor(r, g, b);
      
      // Reset after a short delay
      setTimeout(() => {
        button.style.backgroundColor = '';
        button.style.color = '';
        this.currentPlayingColorIndex = -1;
      }, 300);
    }
  }
  
  // Get contrast color for text
  getContrastColor(r, g, b) {
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? '#000000' : '#ffffff';
  }
  
  // Bind events for all interactive elements
  bindEvents() {
    // Banner speed control
    this.elements.bannerSpeedSlider.addEventListener('input', (e) => {
      this.bannerSpeed = parseFloat(e.target.value);
      this.updateSpeedDisplay();
      this.updateMandalaRotations();
    });
    
    // Aspiral play button
    this.elements.aspiralPlayBtn.addEventListener('click', () => {
      this.playAspiralAnimation();
    });
    
    // Aspiral speed control
    this.elements.aspiralSpeedSlider.addEventListener('input', (e) => {
      this.aspiralAnimationSpeed = parseFloat(e.target.value);
      this.updateAspiralSpeedLabel();
    });
    
    // Initialize aspiral speed label
    this.updateAspiralSpeedLabel();
  }

  // Update aspiral speed label dynamically
  updateAspiralSpeedLabel() {
    if (this.elements.aspiralSpeedLabel) {
      this.elements.aspiralSpeedLabel.textContent = `Speed: ${this.aspiralAnimationSpeed.toFixed(2)}`;
    }
  }
  
  // Update individual mandala rotations in the panel
  updateMandalaRotations() {
    const bannerMandalas = this.elements.mandalaCarousel.querySelectorAll('.banner-mandala');
    bannerMandalas.forEach((mandala, index) => {
      if (Math.abs(this.bannerSpeed) > 0) {
        const rotationSpeed = this.bannerSpeed;
        const duration = Math.abs(10 / rotationSpeed);
        const direction = rotationSpeed >= 0 ? 'rotate-mandala' : 'rotate-mandala-reverse';
        
        mandala.style.animation = `${direction} ${duration}s linear infinite`;
      } else {
        mandala.style.animation = 'none';
      }
    });
  }
  
  // Stop all animations and cleanup
  stop() {
    this.stopAspiralAnimation();
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (playgroundApp) {
    switch(e.key) {
      case ' ':
        e.preventDefault();
        playgroundApp.playAspiralAnimation();
        break;
      case 'ArrowLeft':
        const prevIndex = (playgroundApp.selectedMandalaIndex - 1 + playgroundApp.mandalas.length) % playgroundApp.mandalas.length;
        playgroundApp.selectMandala(prevIndex);
        break;
      case 'ArrowRight':
        const nextIndex = (playgroundApp.selectedMandalaIndex + 1) % playgroundApp.mandalas.length;
        playgroundApp.selectMandala(nextIndex);
        break;
      case 'r':
        const randomIndex = Math.floor(Math.random() * playgroundApp.mandalas.length);
        playgroundApp.selectMandala(randomIndex);
        break;
    }
  }
});
</script>
